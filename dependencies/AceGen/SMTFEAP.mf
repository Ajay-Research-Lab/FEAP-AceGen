""<*allFunctionNames=#[[1,1]]&/@SMSFunctions;" "*>""
!$Id:$
      subroutine ""<*SMSSubroutineName["elmt"]*>""(d,ul,xl,ix,tl,s,p,ndf,ndm,nst,isw)

!      * * F E A P * * A Finite Element Analysis Program

!....  Copyright (c) 1984-2020: Regents of the University of California
!                               All rights reserved

!-----[--.----+----.----+----.-----------------------------------------]
!     Modification log                                Date (dd/mm/year)
!-----[--.----+----.----+----.-----------------------------------------]
!     Purpose:

!     Inputs:
!       d(*)          - Material set parameters
!       ul(ndf,nen,*) - Solution parameters
!       xl(ndm,nen)   - Element nodal coordinates
!       ix(nen1)      - Element global node numbers
!       tl(nen)       - Element vector (e.g., nodal temperatures)
!       ndf           - Maximum no dof's/node
!       ndm           - Mesh spatial dimension
!       nst           - Element matrix/vector dimension
!       isw           - Switch parameter (set by input commands)

!     Outputs:
!       s(nst,nst,2)  - Element matrix (stiffness, mass, etc.)
!       p(nst,2)      - Element vector (residual, lump mass, etc.)
!-----[--.----+----.----+----.-----------------------------------------]

      implicit none

      include 'debugs.h'
      include 'bdata.h'
      include 'cdata.h'
      include 'eldata.h'
      include 'eltran.h'
      include 'hdata.h'
      include 'iofile.h'
      include 'umac1.h'                 ! utx(1)
      include 'comblk.h'

      integer       ::  ndf             ! Max DOF's/node
      integer       ::  ndm             ! Mesh spatial dimention
      integer       ::  nst             ! Matrix 's' dimension
      integer       ::  isw             ! Switch for solution steps
      integer       ::  ix(*)           ! Element global nodes
      real (kind=8) ::  d(*)            ! Material set parameters
      real (kind=8) ::  ul(ndf,nen,*)   ! Local nodal solutions
      real (kind=8) ::  xl(ndm,*)       ! Local nodal coordinates
      real (kind=8) ::  tl(*)           ! Local nodal load array
      real (kind=8) ::  s(nst,nst,*)    ! Element matrix
      real (kind=8) ::  p(ndf,*)        ! Element vector    
      logical       ::  symmetric       ! Is matrix symmetric
      logical       ::  errck           ! For error in inputs

      character (len=15) :: datades(<*Min[10,Length[SMSDomainDataNames]]*>)
      logical       ::  pinput
      integer       ::  i,j,dofacegen
      integer       ::  dg(<*SMSNoNodes*>)
      real (kind=8) ::  td(<*Min[10,Length[SMSDomainDataNames]]*>)
      real (kind=8) ::  v(<*SMSWorkLength*>)          ! AceGen Storage
      real (kind=8) ::  ua(6,22)         ! AceGen Storage
      real (kind=8) ::  k(22,22)          ! AceGen stiffness
      real (kind=8) ::  c(22,22)          ! AceGen damping
      real (kind=8) ::  m(22,22)          ! AceGen mass
      real (kind=8) ::  r(22)            ! AceGen residual

      save

      data  dg /""<*SMCListToString[SMSDOFGlobal,15,InputForm,",", ",\n     & "]*>""/
      symmetric=""<*If[SMSSymmetricTangent,".true.",".false."]*>""

      dofacegen = 0
      do i=1,<*SMSNoNodes*>
        dofacegen = dofacegen + dg(i)
      enddo

      if(isw.lt.0) then
        utx(1) = <*SMSSessionName*>

      elseif(isw.eq.1) then                ! Input material set data
        pstyp = ndm                        ! Sets plot dimension (1,2,3)
        errck = pinput(td,10)
        do i=1,<*Min[10,Length[SMSDomainDataNames]]*>
          d(i) = td(i)
        end do

!     Output material set data
        ""<*StringJoin@@
        MapIndexed["\n      datades("<>ToString[#2[[1]]]<>")='"<>SMCToString[#1,FullForm,50]<>"'\n"&, SMSDomainDataNames]*>""
        write(iow,"(10x,f15.5,A3,A50)")
     #     (d(i)," = ",datades(i),i=1,<*Length[SMSDomainDataNames]*>)

!       Set active dof's
        call SM_activedofs(dg, 9, ix, ndf)
      
      elseif(isw.eq.2) then                ! Check input data
      elseif(isw.eq.3 .or.isw.eq.6) then   ! Compute residual/tangent
!       Map dofs
        call SM_ua_set(ul,ndf,nen,ua,dg,9)
!       Initialize element arrays
        k(:,:) = 0.0d0
        c(:,:) = 0.0d0
        m(:,:) = 0.0d0
        r(:)   = 0.0d0
!       Form arrays from AceGen
        call ""<*SMSSubroutineName["SKR"]*>""(v,d,ua,xl,k,c,m,r,hr(nh1),hr(nh2),dofacegen) 
        if(debug) then
          call mprint(k,dofacegen,dofacegen,dofacegen,'ACE_K')
          call mprint(c,dofacegen,dofacegen,dofacegen,'ACE_C')
          call mprint(m,dofacegen,dofacegen,dofacegen,'ACE_M')
          call mprint(r,1,dofacegen,1,'ACE_R')
        endif
!       Combine tangent
        k(:,:) = k(:,:)*ctan(1) + c(:,:)*ctan(2) + m(:,:)*ctan(3)
!       Fill symmetric part
        if(symmetric) then
          do j = 1,dofacegen
            do i = j+1,dofacegen
              k(i,j) = k(j,i)
            end do ! i
          end do ! j
        end if
!       Map to FEAP storage
        call smsall2nst(k,r,s,p,dofacegen,nst,dg,<*SMSNoNodes*>)
      elseif(isw.eq.4 .or.isw.eq.8) then   ! Output/plot element data
      elseif(isw.eq.5) then                ! Compute mass matrix
      elseif(isw.eq.14) then               ! Set non-zero history values
      endif

      end subroutine ""<*SMSSubroutineName["elmt"]*>""


!******************* S U B R O U T I N E **********************
      SUBROUTINE SKR10(v,d,ul,xl,s,c,m,p,ht,hp,ig)
      IMPLICIT NONE
      INTEGER i1,ig
      DOUBLE PRECISION v(<*SMSWorkLength*>),d(*),ul(6,*),xl(<*SMSNoDimensions*>,*)
     &,s(ig,ig),c(ig,ig),m(ig,ig),p(ig),ht(*),hp(*)

      INTEGER          ngpo
      DOUBLE PRECISION sg2(3,9), gp(4,9)
      
      call int2d(3,ngpo,sg2)
      gp(1:2,1:ngpo) = sg2(1:2,1:ngpo)
      gp(4,1:ngpo) = sg2(3,1:ngpo)
